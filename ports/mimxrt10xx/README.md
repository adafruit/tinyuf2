# TinyUF2 for iMXRT

TinyUF2 port of iMXRT runs entirely on SRAM which is not only super fast but also easy to perform self-update. After powering on, if TinyUF2 already exists on external flash, it will be loaded to internal SRAM and start executing from there.

## Initial Flash

To initially flash TinyUF2 on your blank board or board that is shipped with other bootloader. You could either use external debugger or BootROM

### External Debugger

jlink or pyocd can be used to program .bin file to appropriate address on external flash which is typically **0x60000000** (RT1062), **0x60000400** (RT1011), or **0x30000400** (RT1170). This can be done with `flash-jlink-bin` or `flash-pyocd-bin` make target.

```
make BOARD=metro_m7_1011 flash-jlink-bin
```

### Serial Download Mode with BootROM

iMXRT has built-in BootROM that implements the Serial Download Protocol (SDP), which can be used to load & execute TinyUF2 to SRAM with `spdhost` tool via USB. You need to

1. Install the NXP SPSDK with `pip install spsdk` more details is described in the [SPSDK Installation Guide](https://spsdk.readthedocs.io/en/latest/usage/installation.html).If you are running Linux, make sure your user has permission for accessing `hidraw` (more details below)

2. Power up your board with the Boot Mode switch set to `BOOT_MODE[1:0]=01` to enter Serial Download mode. Note: Serial Download mode also automatically run with blank flash, therefore you don't have to manual change it in your production run.

3. Run `flash-sdp` make target which in turn uses the `sdphost` with correct address and arguments to load and execute TinyUF2. While running, TinyUF2 will program the external flash with its SRAM's image.

  ```
  make BOARD=metro_m7_1011 flash-sdp
  ```

In case you wonder, the flash-sdp target will execute following 2 commands. Note: each rt10xx mcu has different vid/pid and different SRAM address, example is for rt1011.

  ```
  sdphost -u 0x1fc9,0x0145 write-file 0x20206400 _build/metro_m7_1011/tinyuf2-metro_m7_1011.bin
  sdphost -u 0x1fc9,0x0145 jump-address 0x20207000
  ```

4. Switch back `BOOT_MODE[1:0]=10` to boot from xip flash

Note: Since SDP with BootROM doesn't requires external debugger and always exists regardless of the external flash, this method can also be used to de-brick your board should it be needed.

## Update to newer version

Double tap to enter bootloader mode, then simply drag & drop `update-tinyuf2_BOARD.uf2` into BOOT drive to update. The update file can be generated by running make with `self-update` target or simply download it from [release page](https://github.com/adafruit/tinyuf2/releases).

## RT1170/RT1176 Support

The RT1170/RT1176 requires a different flashing approach than other RT10xx chips. The SDP (Serial Download Protocol) method used by other chips does not work reliably for RT1170 because:
- The RT1170 ROM bootloader uses `blhost` protocol instead of `sdphost`
- Self-programming to flash is disabled for RT1176 builds

**For RT1170, you must use `FLASH_BUILD=1` and flash via a debugger.**

### Building for RT1170

```
make BOARD=imxrt1170_evk FLASH_BUILD=1 all
```

This creates a flash-resident (XIP) build that executes directly from flash. Key differences:
- Uses `MIMXRT1176_flash.ld` linker script (code linked at 0x3000xxxx)
- Data/BSS placed in DTCM (0x20000000)
- Clock configuration preserves ROM bootloader settings when running from flash

The flash layout for RT1170 is:
- **0x30000400**: FCFB (FlexSPI Configuration Block)
- **0x30001000**: IVT (Image Vector Table)
- **0x30002000**: Application code (vector table + text)

### RT1170-EVK Boot Switch Settings

The RT1170-EVK/EVKB uses SW1 (4-position DIP switch) to select boot mode:

| Mode  | SW1[1] | SW1[2] | SW1[3] | SW1[4] | Description |
|-------|--------|--------|--------|--------|-------------|
| SDP   | OFF    | OFF    | OFF    | ON     | Serial Download Mode (for debugger access) |
| Flash | OFF    | OFF    | ON     | OFF    | Internal Boot from flash (normal operation) |

Note: OFF = switch down/open, ON = switch up/closed.

### Flashing TinyUF2 to RT1170-EVK

**Requirements:** A debug probe (MCU-Link on the EVK, or external J-Link/CMSIS-DAP) and LinkServer or equivalent flash tool.

**Procedure:**

1. Build the flash-resident version:
   ```
   make BOARD=imxrt1170_evk FLASH_BUILD=1 clean all
   ```

2. Connect the debug probe (MCU-Link is built into the EVK)

3. Set SW1 to Flash boot mode: **0-0-1-0** (only switch 3 ON)

4. Flash the ELF file using LinkServer:
   ```
   LinkServer flash MIMXRT1176xxxxx:MIMXRT1170-EVK-CM7-ONLY erase
   LinkServer flash MIMXRT1176xxxxx:MIMXRT1170-EVK-CM7-ONLY load _build/imxrt1170_evk/tinyuf2-imxrt1170_evk.elf
   ```

5. Reset the board - TinyUF2 should enumerate as USB mass storage device "RT1170BOOT"

**Alternative using pyocd** (if LinkServer is not available):
```
pyocd erase -t mimxrt1170_cm7 --chip
pyocd load -t mimxrt1170_cm7 _build/imxrt1170_evk/tinyuf2-imxrt1170_evk.elf
pyocd reset -t mimxrt1170_cm7
```

Note: pyocd flash programming may not work reliably on all RT1170 boards. LinkServer is recommended.

## Supported Boards

- [Adafruit Metro M7 1011](https://www.adafruit.com/product/4950)
- [MIMX RT1010 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/i.mx-rt1010-evaluation-kit:MIMXRT1010-EVK)
- [MIMX RT1020 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/i.mx-rt1020-evaluation-kit:MIMXRT1020-EVK)
- [MIMX RT1060 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/mimxrt1060-evk-i.mx-rt1060-evaluation-kit:MIMXRT1060-EVK)
- [MIMX RT1170 Evaluation Kit](https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/i-mx-rt1170-evaluation-kit:MIMXRT1170-EVK)
- [Teensy 4.0](https://www.pjrc.com/store/teensy40.html)
- [Teensy 4.1](https://www.pjrc.com/store/teensy41.html)


## Linux hidraw access

Linux requires setting permissions for accessing hidraw devices.  This is done by adding udev rules.  Follow these instructions to add permission.

1. Create file named `50-nxp.rules` with these contents:
  ```
  KERNEL=="hidraw*", ATTRS{idVendor}=="1fc9", MODE="0666"
  ```

2. Copy `50-nxp.rules` to `/etc/udev/rules.d/50-nxp.rules`

3. Reload the rules:
  ```
  sudo udevadm control --reload-rules
  sudo udevadm trigger
  ```
