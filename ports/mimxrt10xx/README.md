# TinyUF2 for iMXRT

TinyUF2 port of iMXRT runs entirely on SRAM which is not only super fast but also easy to perform self-update. After powering on, if TinyUF2 already exists on external flash, it will be loaded to internal SRAM and start executing from there.

## Initial Flash

To initially flash TinyUF2 on your blank board or board that is shipped with other bootloader. You could either use external debugger or BootROM

### External Debugger

jlink or pyocd can be used to program .bin file to appropriate address on external flash which is typically **0x60000000** (RT1062), **0x60000400** (RT1011), or **0x30000400** (RT1170). This can be done with `flash-jlink-bin` or `flash-pyocd-bin` make target.

```
make BOARD=metro_m7_1011 flash-jlink-bin
```

### Serial Download Mode with BootROM

iMXRT has built-in BootROM that implements the Serial Download Protocol (SDP), which can be used to load & execute TinyUF2 to SRAM with `spdhost` tool via USB. You need to

1. Install the NXP SPSDK with `pip install spsdk` more details is described in the [SPSDK Installation Guide](https://spsdk.readthedocs.io/en/latest/usage/installation.html).If you are running Linux, make sure your user has permission for accessing `hidraw` (more details below)

2. Power up your board with the Boot Mode switch set to `BOOT_MODE[1:0]=01` to enter Serial Download mode. Note: Serial Download mode also automatically run with blank flash, therefore you don't have to manual change it in your production run.

3. Run `flash-sdp` make target which in turn uses the `sdphost` with correct address and arguments to load and execute TinyUF2. While running, TinyUF2 will program the external flash with its SRAM's image.

  ```
  make BOARD=metro_m7_1011 flash-sdp
  ```

In case you wonder, the flash-sdp target will execute following 2 commands. Note: each rt10xx mcu has different vid/pid and different SRAM address, example is for rt1011.

  ```
  sdphost -u 0x1fc9,0x0145 write-file 0x20206400 _build/metro_m7_1011/tinyuf2-metro_m7_1011.bin
  sdphost -u 0x1fc9,0x0145 jump-address 0x20207000
  ```

4. Switch back `BOOT_MODE[1:0]=10` to boot from xip flash

Note: Since SDP with BootROM doesn't requires external debugger and always exists regardless of the external flash, this method can also be used to de-brick your board should it be needed.

## Update to newer version

Double tap to enter bootloader mode, then simply drag & drop `update-tinyuf2_BOARD.uf2` into BOOT drive to update. The update file can be generated by running make with `self-update` target or simply download it from [release page](https://github.com/adafruit/tinyuf2/releases).

## RT1170/RT1176 Support

The RT1170/RT1176 uses a different ROM bootloader protocol than other RT10xx chips. While other chips use `sdphost` (SDP protocol) with direct RAM load and self-flash, the RT1170 uses `blhost` (MCU bootloader protocol) with a two-stage flashloader approach.

### Building for RT1170

Build with `FLASH_BUILD=1` to create a flash-resident image:

```
make BOARD=imxrt1170_evk FLASH_BUILD=1 clean all
```

### RT1170-EVKB Boot Switch Settings

The RT1170-EVKB uses SW1 (8-position DIP switch) to select boot mode. Only the first 4 switches are relevant for boot mode:

| Mode  | SW1[1] | SW1[2] | SW1[3] | SW1[4] | Description |
|-------|--------|--------|--------|--------|-------------|
| SDP   | OFF    | OFF    | OFF    | ON     | Serial Download Mode (for initial flashing) |
| Flash | OFF    | OFF    | ON     | OFF    | Boot from FlexSPI NOR (normal operation) |

Note: OFF = switch towards OFF marking, ON = switch towards ON marking. SW1[5-8] should be OFF.

### Flashing TinyUF2 to RT1170 via Serial Download Mode

The RT1170 requires a two-stage flashing process using an NXP flashloader. This is automated via the `flash-sdp` make target.

#### Quick Start (Automated)

1. **Install the NXP SPSDK**: `pip install spsdk`

2. **Obtain the NXP flashloader binary** (`ivt_flashloader.bin`):
   - Build from MCUXpresso SDK flashloader example, or
   - Extract from NXP MCUXpresso Secure Provisioning Tool

3. **Set boot switches to SDP mode** (see boot switch table above)

4. **Connect USB** to the board's USB-OTG port

5. **Build and flash**:
   ```
   make BOARD=imxrt1170_evk FLASH_BUILD=1 flash-sdp FLASHLOADER=/path/to/ivt_flashloader.bin
   ```

6. **Set boot switches to Flash mode** (see boot switch table above)

7. **Reset the board** - TinyUF2 should enumerate as USB mass storage device

#### Manual Steps (Reference)

The `flash-sdp` target executes these commands:

1. **Load the flashloader** (board appears as USB 0x1fc9:0x013d):
   ```
   blhost -u 0x1fc9,0x013d load-image ivt_flashloader.bin
   ```
   Wait 2-3 seconds for USB re-enumeration. The flashloader appears as USB 0x15a2:0x0073.

2. **Configure QSPI flash**:
   ```
   blhost -u 0x15a2,0x0073 fill-memory 0x00002000 4 0xCF900001
   blhost -u 0x15a2,0x0073 configure-memory 9 0x00002000
   blhost -u 0x15a2,0x0073 fill-memory 0x00002000 4 0xC0000007
   blhost -u 0x15a2,0x0073 configure-memory 9 0x00002000
   ```

3. **Erase and write TinyUF2**:
   ```
   blhost -u 0x15a2,0x0073 flash-erase-region 0x30000400 0x10000 9
   blhost -u 0x15a2,0x0073 write-memory 0x30000400 _build/imxrt1170_evk/tinyuf2-imxrt1170_evk.bin
   ```

### Alternative: Flashing via Debug Probe

If you have a debug probe (MCU-Link, J-Link, or CMSIS-DAP):

```
make BOARD=imxrt1170_evk FLASH_BUILD=1 clean all
```

Then flash using LinkServer or pyocd:
```
# LinkServer
LinkServer flash MIMXRT1176xxxxx:MIMXRT1170-EVK-CM7-ONLY load _build/imxrt1170_evk/tinyuf2-imxrt1170_evk.elf

# pyocd
pyocd load -t mimxrt1170_cm7 _build/imxrt1170_evk/tinyuf2-imxrt1170_evk.elf
```

## Supported Boards

- [Adafruit Metro M7 1011](https://www.adafruit.com/product/4950)
- [MIMX RT1010 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/i.mx-rt1010-evaluation-kit:MIMXRT1010-EVK)
- [MIMX RT1020 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/i.mx-rt1020-evaluation-kit:MIMXRT1020-EVK)
- [MIMX RT1060 Evaluation Kit](https://www.nxp.com/design/development-boards/i.mx-evaluation-and-development-boards/mimxrt1060-evk-i.mx-rt1060-evaluation-kit:MIMXRT1060-EVK)
- [MIMX RT1170 Evaluation Kit](https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/i-mx-rt1170-evaluation-kit:MIMXRT1170-EVK)
- [Teensy 4.0](https://www.pjrc.com/store/teensy40.html)
- [Teensy 4.1](https://www.pjrc.com/store/teensy41.html)


## Linux hidraw access

Linux requires setting permissions for accessing hidraw devices.  This is done by adding udev rules.  Follow these instructions to add permission.

1. Create file named `50-nxp.rules` with these contents:
  ```
  KERNEL=="hidraw*", ATTRS{idVendor}=="1fc9", MODE="0666"
  ```

2. Copy `50-nxp.rules` to `/etc/udev/rules.d/50-nxp.rules`

3. Reload the rules:
  ```
  sudo udevadm control --reload-rules
  sudo udevadm trigger
  ```
